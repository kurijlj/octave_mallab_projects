function plot_measurement(AT, ss, window, varargin)
%% -----------------------------------------------------------------------------
%%
%% Function 'plot_measurement':
%%
%% -----------------------------------------------------------------------------
%
%  Use:
%       -- plot_measurement(AT, ss, window)
%       -- plot_measurement(..., "PROPERTY", VALUE, ...)
%
%% Description:
%       Plot measurement ROIs on the scansets pixel data. This is a utility
%       function to give a visual overview of the ROIs that will be measured on
%       the given scanset ss for the given data points AT and for the given
%       window.
%
%       Function parameters:
%       AT: two column matrix of double class
%           Array of coordinates to sample data from for the given scanset.
%
%       ss: instance of the Scanset class
%           A scanset from which to sample dara for the given coordinates.
%
%       window: two elements row vector
%           Two elements row vector determing the size of the sampling window.
%           Window can't be smaller than 1x1 pixels and can't be larger than
%           200x200 pixels.
%
%       Optional parameters:
%       Smoothing: PixelDataSmotthing, def. PixelDataSmoothing()
%           Data smoothing algorithm and parameters of the smoothing algorithm
%           to be used on the averaged pixel data. By default no smoothing is
%           applied to the pixel data. See help on PixelDataSmoothing class for
%           details.
%
%       rsl: double, def. [](0x0)
%           Two-element vector [XResolution, YResolution] specifying the image
%           resolution along the image width and image height, respectively.
%
%       rslu: string, def. 'None'
%           String specifying resolution units of the image. It can have one of
%           three possible values: 1) "None" no resolution is specified; 2)
%           "dpi"; and 3) "dpcm".
%
% -----------------------------------------------------------------------------
    fname = 'plot_measurement';
    use_case_a = sprintf(' -- %s(AT, ss, window)', fname);
    use_case_b = sprintf(' -- %s(..., "PROPERTY", VALUE, ...)', fname);

    if(3 > nargin)
        % Invalid call to function
        error( ...
            'Invalid call to %s. Correct usage is:\n%s\n%s', ...
            fname, ...
            use_case_a, ...
            use_case_b ...
            );

    endif;

    % Initialize resolution multiplier and axes units string ------------------
    frsl = 1;
    xscunits = "X [points]";
    yscunits = "Y [points]";

    % Validate positional input arguments -------------------------------------

    % Validate AT argument
    validateattributes( ...
        AT, ...
        {'float'}, ...
        { ...
            '2d', ...
            'finite', ...
            'nonempty', ...
            'nonnan' ...
            }, ...
        fname, ...
        'AT' ...
        );

    if(size(AT, 2) > 2)
        error( ...
            sprintf( ...
                cstrcat( ...
                    "%s: AT must be a two column matrix of integers ", ...
                    "(got %d columns)" ...
                    ), ...
                fname, ...
                size(AT, 2) ...
                ) ...
            );

    endif;  % size(AT, 2) > 2

    % Validate scanset argument
    if(~isa(ss, 'Scanset'))
        error( ...
            '%s: ss must be an instance of the "Scanset" class', ...
            fname ...
            );

    endif;  % ~isa(ss, 'Scanset')

    if(~ss.isvalid())
        error( ...
            '%s: ss must be a valid Scanset instance', ...
            fname ...
            );

    endif;  % ~ss.isvalid()

    l = ss.data_size()(1);
    w = ss.data_size()(2);

    % Validate window argument
    validateattributes( ...
        window, ...
        {'float'}, ...
        { ...
            'row', ...
            'finite', ...
            'nonempty', ...
            'nonnan', ...
            'numel', 2, ...
            'integer', ...
            '>=', 1, ...
            '<=', 200 ...
            }, ...
        fname, ...
        'window' ...
        );

    % Window can't be larger than the scanset's pixel data bounds
    if(l < window(2) || w < window(1))
        % Recalculate the window size
        if(l < window(2)) window(2) = l; endif;
        if(w < window(1)) window(1) = w; endif;

        % Issue a warning
        warning( ...
            sprintf( ...
                cstrcat( ...
                    "%s: data sample area larger than containing pixel ", ...
                    "data area. Resizing to %dx%d" ...
                    ), ...
                fname, ...
                window ...
                ) ...
            );

    endif;  % l < size(window, 1) || w < size(window, 2)

    % Vaidate optional input argument -----------------------------------------

    % Parse arguments
    [ ...
        pos, ...
        pds, ...
        rsl, ...
        rslu ...
        ] = parseparams( ...
        varargin, ...
        'Smoothing', PixelDataSmoothing(), ...
        'Resolution', [], ...
        'ResolutionUnits', 'None' ...
        );

    if(0 ~= numel(pos))
        % Invalid call to function
        error( ...
            'Invalid call to %s. Correct usage is:\n%s\n%s', ...
            fname, ...
            use_case_a, ...
            use_case_b ...
            );

    endif;  % 0 ~= numel(pos)

    % Validate the Smoothing argument
    if(~isa(pds, 'PixelDataSmoothing'))
        error( ...
            sprintf( ...
                cstrcat( ...
                    '%s: Smoothing must be an instance of the ', ...
                    '"PixelDataSmoothing" class' ...
                    ), ...
                fname ...
                ) ...
            );

    endif;  % ~isa(pds, 'PixelDataSmoothing')

    % Validate resolution units argument
    validatestring( ...
        rslu, ...
        { ...
            'None', ...
            'dpi', ...
            'dpcm' ...
            }, ...
        fname, ...
        'ResolutionUnits' ...
        );

    % Validate resolution argument
    if(isequal('dpi', rslu))
        validateattributes( ...
            rsl, ...
            {'float'}, ...
            { ...
                '2d', ...
                'finite', ...
                'nonempty', ...
                'nonnan', ...
                'numel', 2, ...
                '>=', 75, ...
                }, ...
            fname, ...
            'Resolution' ...
            );

        % Update reolution multiplier
        frsl = 25.4/rsl(1);
        xscunits = "X [mm]";
        yscunits = "Y [mm]";

    elseif(isequal('dpcm', rslu))
        validateattributes( ...
            rsl, ...
            {'float'}, ...
            { ...
                '1d', ...
                'finite', ...
                'nonempty', ...
                'nonnan', ...
                'numel', 2, ...
                '>=', 30, ...
                }, ...
            fname, ...
            'Resolution' ...
            );

        % Update reolution multiplier
        frsl = 10.0/rsl(1);
        xscunits = "X [mm]";
        yscunits = "Y [mm]";

    endif;  % We ingore Resolution argument if rslu == "None"

    % Plot the figure ---------------------------------------------------------
    hfig = figure();
    hax  = axes(hfig);

    % If resolution is set rescale axes
    xsc = [1, ss.data_size()(2)].*frsl;
    ysc = [1, ss.data_size()(1)].*frsl;

    % Plot scan on the canvas -------------------------------------------------
    image( ...
        uint16(ss.pixel_data(pds)), ...
        "xdata", xsc, ...
        "ydata", ysc, ...
        "parent", hax ...
        );

    % Plot ROIs ---------------------------------------------------------------

    % Lock the plot so we don't overwrite the ploted image
    hold(hax, 'on');

    idx = 1;
    while(size(AT, 1) >= idx)
        % For each point in the point coordinates vector calculate coordinates
        % of the sampling area and check if bounds of the sample area fall
        % outside scanset's pixel data bounds.
        x = AT(idx, 1);
        y = AT(idx, 2);
        whh = round((window(2) - 1)/2);
        whw = round((window(1) - 1)/2);
        window = [2*whw + 1, 2*whh + 1];

        % Calculate bounding box coordinates
        bbox = [ ...
            y - whh, x - whw; ...
            y + whh, x + whw ...
            ];

        % Check if upper left corner of the bounding box falls outside pixel
        % data area
        if(bbox(1, 1) < 1)
            % Recalculate coordinates position
            y = y + abs(1 - bbox(1, 1));
            bbox(1, 1) = y - whh;
            bbox(2, 1) = y + whh;

            % Issue a warning message
            warning( ...
                sprintf( ...
                    cstrcat( ...
                        "%s: data sample area spans outside containing ", ...
                        "pixel data area. Recalculating y position for ", ...
                        "the data sample #%d ..." ...
                        ), ...
                    fname, ...
                    idx ...
                    ) ...
                );

        endif;  % bbox(1, 1) < 1
        if(bbox(1, 2) < 1)
            % Recalculate coordinates position
            x = x + abs(1 - bbox(1, 2));
            bbox(1, 2) = x - whw;
            bbox(2, 2) = x + whw;

            % Issue a warning message
            warning( ...
                sprintf( ...
                    cstrcat( ...
                        "%s: data sample area spans outside containing ", ...
                        "pixel data area. Recalculating x position for ", ...
                        "the data sample #%d ..." ...
                        ), ...
                    fname, ...
                    idx ...
                    ) ...
                );

        endif;  % bbox(1, 2) < 1

        % Check if lower right corner of the bounding box falls outside pixel
        % data area
        if(bbox(2, 1) > l)
            % Recalculate coordinates position
            y = y - abs(l - bbox(1, 1));
            bbox(1, 1) = y - whh;
            bbox(2, 1) = y + whh;

            % Issue a warning message
            warning( ...
                sprintf( ...
                    cstrcat( ...
                        "%s: data sample area spans outside containing ", ...
                        "pixel data area. Recalculating y position for ", ...
                        "the data sample #%d ..." ...
                        ), ...
                    fname, ...
                    idx ...
                    ) ...
                );

        endif;  % bbox(2, 1) > l
        if(bbox(2, 2) > w)
            % Recalculate coordinates position
            x = x - abs(w - bbox(1, 2));
            bbox(1, 2) = x - whw;
            bbox(2, 2) = x + whw;

            % Issue a warning message
            warning( ...
                sprintf( ...
                    cstrcat( ...
                        "%s: data sample area spans outside containing ", ...
                        "pixel data area. Recalculating x position for ", ...
                        "the data sample #%d ..." ...
                        ), ...
                    fname, ...
                    idx ...
                    ) ...
                );

        endif;  % bbox(2, 2) > w

        plot( ...
            [bbox(1, 2), bbox(1, 2), bbox(2, 2), bbox(2, 2), bbox(1, 2)].*frsl, ...
            [bbox(1, 1), bbox(2, 1), bbox(2, 1), bbox(1, 1), bbox(1, 1)].*frsl, ...
            "color", "#33CC33" ...
            );
        plot(x*frsl, y*frsl, "color", "#33CC33", "marker", "+");
        text( ...
            % (bbox(1, 2) - 7*floor(log10(idx) + 1))*frsl, ...
            (bbox(1, 2) - floor(log10(idx) + 1))*frsl, ...
            bbox(2, 1)*frsl, ...
            sprintf("%d.", idx), ...
            "fontsize", 14, ...
            "color", "#33CC33", ...
            "horizontalalignment", "right", ...
            "verticalalignment", "bottom" ...
            );

        ++idx;

    endwhile;  % End of AT rows trversal

    % Now we can unlock the plot
    hold(hax, 'off');

    % Adjust axes data aspect to the scan -------------------------------------
    daspect(hax, [1 1]);
    xlabel(hax, xscunits);
    ylabel(hax, yscunits);
    title(hax, ss.sstitle);

endfunction;  % plot_measurement()
